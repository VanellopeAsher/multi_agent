{
  "instance_id": "programdev_19",
  "problem": "Create a Tetris game. Tetrominoes fall from the top, and the player can move or rotate them before they land. Completed lines are cleared, and scoring increases accordingly. The game ends when no more pieces can be placed. The board updates after each move or drop. Include all seven standard Tetromino shapes and consider increasing drop speed as the game progresses.",
  "roles": {
    "agent1": "SimpleCoder",
    "agent2": "SimpleReviewer",
    "agent3": "SimpleTester"
  },
  "history": [
    {
      "role": "user",
      "name": "user",
      "content": "Create a Tetris game. Tetrominoes fall from the top, and the player can move or rotate them before they land. Completed lines are cleared, and scoring increases accordingly. The game ends when no more pieces can be placed. The board updates after each move or drop. Include all seven standard Tetromino shapes and consider increasing drop speed as the game progresses."
    },
    {
      "role": "assistant",
      "name": "SimpleCoder",
      "content": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Screen size\nSCREEN_WIDTH, SCREEN_HEIGHT = 300, 600\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\n\n# Colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nCOLORS = [\n    (0, 255, 255),  # Cyan I\n    (255, 165, 0),  # Orange L\n    (0, 0, 255),    # Blue J\n    (255, 255, 0),  # Yellow O\n    (0, 255, 0),    # Green S\n    (255, 0, 0),    # Red Z\n    (128, 0, 128)   # Purple T\n]\n\n# Tetromino shapes\nSHAPES = [\n    [[1, 1, 1, 1]],  # I\n    [[1, 0, 0], [1, 1, 1]],  # L\n    [[0, 0, 1], [1, 1, 1]],  # J\n    [[1, 1], [1, 1]],  # O\n    [[0, 1, 1], [1, 1, 0]],  # S\n    [[1, 1, 0], [0, 1, 1]],  # Z\n    [[0, 1, 0], [1, 1, 1]]  # T\n]\n\n# Board size\nBOARD_WIDTH, BOARD_HEIGHT = 10, 20\nboard = [[0 for _ in range(BOARD_WIDTH)] for _ in range(BOARD_HEIGHT)]\n\n# Game variables\nclock = pygame.time.Clock()\nfall_time = 0\nfall_speed = 0.3\nlevel_time = 0\nscore = 0\n\nclass Piece(object):\n    def __init__(self, x, y, shape):\n        self.x = x\n        self.y = y\n        self.shape = shape\n        self.color = COLORS[SHAPES.index(shape)]\n        self.rotation = 0\n\ndef create_grid(locked_positions={}):\n    grid = [[(0,0,0) for _ in range(BOARD_WIDTH)] for _ in range(BOARD_HEIGHT)]\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if (j,i) in locked_positions:\n                c = locked_positions[(j,i)]\n                grid[i][j] = c\n    return grid\n\ndef convert_shape_format(piece):\n    positions = []\n    shape = piece.shape[piece.rotation % len(piece.shape)]\n    for i, line in enumerate(shape):\n        row = list(line)\n        for j, column in enumerate(row):\n            if column == '1':\n                positions.append((piece.x + j, piece.y + i))\n    return positions\n\ndef valid_space(piece, grid):\n    accepted_positions = [[(j, i) for j in range(BOARD_WIDTH) if grid[i][j] == (0,0,0)] for i in range(BOARD_HEIGHT)]\n    accepted_positions = [j for sub in accepted_positions for j in sub]\n    formatted = convert_shape_format(piece)\n    for pos in formatted:\n        if pos not in accepted_positions:\n            if pos[1] > -1:\n                return False\n    return True\n\ndef check_lost(positions):\n    for pos in positions:\n        x, y = pos\n        if y < 1:\n            return True\n    return False\n\ndef get_shape():\n    return Piece(5, 0, random.choice(SHAPES))\n\ndef draw_window(surface, grid):\n    surface.fill(BLACK)\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            pygame.draw.rect(surface, grid[i][j], (j*30, i*30, 30, 30), 0)\n    pygame.display.update()\n\ndef clear_rows(grid, locked):\n    inc = 0\n    for i in range(len(grid)-1, -1, -1):\n        row = grid[i]\n        if (0, 0, 0) not in row:\n            inc += 1\n            ind = i\n            for j in range(len(row)):\n                try:\n                    del locked[(j, i)]\n                except:\n                    continue\n    if inc > 0:\n        for key in sorted(list(locked), key=lambda x: x[1])[::-1]:\n            x, y = key\n            if y < ind:\n                newKey = (x, y + inc)\n                locked[newKey] = locked.pop(key)\n    return inc\n\ndef draw_next_shape(shape, surface):\n    font = pygame.font.SysFont('comicsans', 30)\n    label = font.render('Next Shape', 1, (255,255,255))\n    sx = SCREEN_WIDTH - 100\n    sy = SCREEN_HEIGHT - 300\n    format = shape.shape[shape.rotation % len(shape.shape)]\n    for i, line in enumerate(format):\n        row = list(line)\n        for j, column in enumerate(row):\n            if column == '1':\n                pygame.draw.rect(surface, shape.color, (sx + j*30, sy + i*30, 30, 30), 0)\n    surface.blit(label, (sx + 10, sy - 30))\n\ndef update_score(nscore):\n    score = nscore\n\ndef main():\n    global board, score\n    locked_positions = {}\n    grid = create_grid(locked_positions)\n    change_piece = False\n    run = True\n    current_piece = get_shape()\n    next_piece = get_shape()\n    clock = pygame.time.Clock()\n    fall_time = 0\n    level_time = 0\n    score = 0\n\n    while run:\n        grid = create_grid(locked_positions)\n        fall_speed = 0.27\n\n        fall_time += clock.get_rawtime()\n        level_time += clock.get_rawtime()\n        clock.tick()\n\n        if level_time/1000 > 5:\n            level_time = 0\n            if fall_speed > 0.12:\n                fall_speed -= 0.005\n\n        if fall_time/1000 > fall_speed:\n            fall_time = 0\n            current_piece.y += 1\n            if not (valid_space(current_piece, grid)) and current_piece.y > 0:\n                current_piece.y -= 1\n                change_piece = True\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                run = False\n                pygame.display.quit()\n                quit()\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_LEFT:\n                    current_piece.x -= 1\n                    if not valid_space(current_piece, grid):\n                        current_piece.x += 1\n                elif event.key == pygame.K_RIGHT:\n                    current_piece.x += 1\n                    if not valid_space(current_piece, grid):\n                        current_piece.x -= 1\n                elif event.key == pygame.K_UP:\n                    current_piece.rotation = (current_piece.rotation + 1) % len(current_piece.shape)\n                    if not valid_space(current_piece, grid):\n                        current_piece.rotation = (current_piece.rotation - 1) % len(current_piece.shape)\n                elif event.key == pygame.K_DOWN:\n                    current_piece.y += 1\n                    if not valid_space(current_piece, grid):\n                        current_piece.y -= 1\n\n        shape_pos = convert_shape_format(current_piece)\n\n        for i in range(len(shape_pos)):\n            x, y = shape_pos[i]\n            if y > -1:\n                grid[y][x] = current_piece.color\n\n        if change_piece:\n            for pos in shape_pos:\n                p = (pos[0], pos[1])\n                locked_positions[p] = current_piece.color\n            current_piece = next_piece\n            next_piece = get_shape()\n            change_piece = False\n            score += clear_rows(grid, locked_positions) * 10\n\n        draw_window(screen, grid)\n        draw_next_shape(next_piece, screen)\n\n        if check_lost(locked_positions):\n            run = False\n\n    pygame.display.quit()\n\nmain()\n\n"
    },
    {
      "role": "assistant",
      "name": "SimpleTester",
      "content": "import pytest\nfrom tetris_game import Piece, create_grid, valid_space, check_lost, clear_rows\n\ndef test_piece_initialization():\n    piece = Piece(5, 0, [[1, 1, 1, 1]])  # I shape\n    assert piece.x == 5\n    assert piece.y == 0\n    assert piece.shape == [[1, 1, 1, 1]]\n    assert piece.rotation == 0\n\ndef test_create_grid_empty():\n    grid = create_grid()\n    assert len(grid) == 20  # BOARD_HEIGHT\n    assert len(grid[0]) == 10  # BOARD_WIDTH\n    assert grid[0][0] == (0, 0, 0)  # Empty cell\n\ndef test_valid_space_true():\n    piece = Piece(5, 0, [[1, 1, 1, 1]])  # I shape\n    grid = create_grid()\n    assert valid_space(piece, grid) == True\n\ndef test_check_lost_false():\n    positions = {(5, 19): (255, 0, 0)}  # Not at the top of the grid\n    assert check_lost(positions) == False\n\ndef test_clear_rows_single():\n    locked = {(i, 19): (255, 0, 0) for i in range(10)}  # A complete row at the bottom\n    grid = create_grid(locked)\n    assert clear_rows(grid, locked) == 1\n    assert not locked  # All locked positions should be cleared\n\n"
    },
    {
      "role": "assistant",
      "name": "SimpleReviewer",
      "content": "One critical comment on the provided test cases is that there is a lack of testing for edge cases and functionalities that are crucial for the Tetris game's mechanics. For example, there are no tests for the rotation functionality of the pieces to ensure that a piece can correctly rotate within the bounds of the grid and without overlapping with locked positions. Testing rotation is essential because it directly impacts the gameplay, allowing players to fit pieces into tight spaces and clear multiple rows simultaneously. Without verifying the correct behavior of piece rotation, especially near the edges of the board or when close to other locked pieces, there's a risk that the game might not respond as expected during these critical moments, potentially frustrating players or leading to incorrect game states.\n"
    },
    {
      "role": "assistant",
      "name": "SimpleTester",
      "content": "import pytest\nfrom tetris_game import Piece, convert_shape_format, valid_space\n\ndef test_piece_rotation_within_bounds():\n    piece = Piece(5, 0, [[1, 1, 1, 1]])  # I shape\n    grid = create_grid()\n    piece.rotation = 1  # Attempt to rotate\n    assert valid_space(piece, grid) == True  # Should still be within bounds after rotation\n\ndef test_piece_rotation_collision_with_locked():\n    piece = Piece(5, 18, [[1, 1, 1, 1]])  # I shape near the bottom\n    locked_positions = {(5, 19): (255, 0, 0)}  # Locked position directly below\n    grid = create_grid(locked_positions)\n    piece.rotation = 1  # Attempt to rotate\n    assert valid_space(piece, grid) == False  # Rotation should collide with locked position\n\ndef test_convert_shape_format_correctness():\n    piece = Piece(5, 0, [[1, 1, 1, 1]])  # I shape\n    expected_positions = [(5, 0), (6, 0), (7, 0), (8, 0)]\n    assert convert_shape_format(piece) == expected_positions\n\ndef test_valid_space_false_for_overflow_left():\n    piece = Piece(-1, 0, [[1, 1, 1, 1]])  # I shape, partially outside the left boundary\n    grid = create_grid()\n    assert valid_space(piece, grid) == False\n\ndef test_valid_space_false_for_overflow_right():\n    piece = Piece(7, 0, [[1, 1, 1, 1]])  # I shape, partially outside the right boundary\n    grid = create_grid()\n    assert valid_space(piece, grid) == False\n\n"
    },
    {
      "role": "assistant",
      "name": "SimpleReviewer",
      "content": "The test cases provided cover a range of important functionalities for the Tetris game, including piece initialization, grid creation, space validation, collision detection, and row clearing. However, one critical comment is the absence of tests for the game's progression mechanics, such as the increase in fall speed over time and the scoring system. These aspects are fundamental to the game's challenge and engagement levels. Testing for increased fall speed would ensure that the game's difficulty progresses at an appropriate pace, keeping players engaged without overwhelming them. Similarly, testing the scoring system is crucial to validate that points are awarded correctly for clearing rows, which is a core motivator for players. Without these tests, there's a risk that the game might not provide a consistently challenging and rewarding experience, potentially affecting its replay value.\n"
    }
  ],
  "label": null,
  "correct": null
}